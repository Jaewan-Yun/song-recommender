!function(t,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports,require("@tensorflow/tfjs-core")):"function"==typeof define&&define.amd?define(["exports","@tensorflow/tfjs-core"],n):n((t="undefined"!=typeof globalThis?globalThis:t||self).tsne={},t.tf)}(this,function(t,C){"use strict";function s(t,n,e){var i=C.webgl.webgl_util.createVertexShader(t,n),o=C.webgl.webgl_util.createFragmentShader(t,e),r=C.webgl.webgl_util.createProgram(t);return C.webgl.webgl_util.callAndCheck(t,function(){return t.attachShader(r,i)}),C.webgl.webgl_util.callAndCheck(t,function(){return t.attachShader(r,o)}),C.webgl.webgl_util.linkProgram(t,r),C.webgl.webgl_util.validateProgram(t,r),r}function l(t,n,e,i,o){C.webgl.webgl_util.validateTextureSize(t,n,e);var r=C.webgl.webgl_util.createTexture(t),a=t.TEXTURE_2D,s=u(t,i),l=h(t,i);return C.webgl.webgl_util.callAndCheck(t,function(){return t.bindTexture(a,r)}),C.webgl.webgl_util.callAndCheck(t,function(){return t.texParameteri(a,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)}),C.webgl.webgl_util.callAndCheck(t,function(){return t.texParameteri(a,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)}),C.webgl.webgl_util.callAndCheck(t,function(){return t.texParameteri(a,t.TEXTURE_MIN_FILTER,t.LINEAR)}),C.webgl.webgl_util.callAndCheck(t,function(){return t.texParameteri(a,t.TEXTURE_MAG_FILTER,t.LINEAR)}),C.webgl.webgl_util.callAndCheck(t,function(){return t.texImage2D(a,0,s,n,e,0,l,g(t),o)}),C.webgl.webgl_util.callAndCheck(t,function(){return t.bindTexture(t.TEXTURE_2D,null)}),r}function M(t,n,e,i,o){C.webgl.webgl_util.validateTextureSize(t,n,e);var r=C.webgl.webgl_util.createTexture(t),a=t.TEXTURE_2D,s=u(t,i),l=h(t,i);return C.webgl.webgl_util.callAndCheck(t,function(){return t.bindTexture(a,r)}),C.webgl.webgl_util.callAndCheck(t,function(){return t.texParameteri(a,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)}),C.webgl.webgl_util.callAndCheck(t,function(){return t.texParameteri(a,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)}),C.webgl.webgl_util.callAndCheck(t,function(){return t.texParameteri(a,t.TEXTURE_MIN_FILTER,t.NEAREST)}),C.webgl.webgl_util.callAndCheck(t,function(){return t.texParameteri(a,t.TEXTURE_MAG_FILTER,t.NEAREST)}),C.webgl.webgl_util.callAndCheck(t,function(){return t.texImage2D(a,0,s,n,e,0,l,g(t),o)}),C.webgl.webgl_util.callAndCheck(t,function(){return t.bindTexture(t.TEXTURE_2D,null)}),r}function u(t,n){return 4===n?t.RGBA32F:3===n?t.RGB32F:2===n?t.RG32F:t.R32F}function h(t,n){return 4===n?t.RGBA:3===n?t.RGB:2===n?t.RG:t.RED}function g(t){return t.FLOAT}function p(t,n){return"#version 300 es\n    precision highp float;\n    uniform sampler2D data_tex;\n    uniform float num_points;\n    uniform float points_per_row_knn;\n    uniform float num_rows_knn;\n    uniform float num_neighs;\n    uniform float iteration;\n\n    #define NUM_PACKED_NEIGHBORS "+n/4+"\n\n    flat in vec4 knn[NUM_PACKED_NEIGHBORS];\n    flat in int point_id;\n    in float neighbor_id;\n\n    const float MAX_DIST = 10e30;\n\n    "+t+"\n\n    out vec4 fragmentColor;\n    void main() {\n      int id = int(neighbor_id/4.);\n      int channel = int(mod(neighbor_id,4.)+0.1);\n\n      if(channel == 0) {\n        fragmentColor = vec4(knn[id].r,0,0,1);\n      }else if(channel == 1) {\n        fragmentColor = vec4(knn[id].g,0,0,1);\n      }else if(channel == 2) {\n        fragmentColor = vec4(knn[id].b,0,0,1);\n      }else if(channel == 3) {\n        fragmentColor = vec4(knn[id].a,0,0,1);\n      }\n\n      //If the neighbor has a valid id i compute the distance squared\n      //otherwise I set it to invalid\n      if(fragmentColor.r >= 0.) {\n        fragmentColor.g = pointDistanceSquared(int(fragmentColor.r),point_id);\n      }else{\n        fragmentColor.g = MAX_DIST;\n      }\n    }\n  "}function m(t){return"\n  precision highp float;\n  #define NEIGH_PER_ITER 20\n  #define NUM_NEIGHBORS "+t+"\n  #define NUM_NEIGHBORS_FLOAT "+t+".\n  #define NUM_PACKED_NEIGHBORS "+t/4+"\n  #define MAX_DIST 10e30\n\n  //attributes\n  in float vertex_id;\n  //uniforms\n  uniform sampler2D data_tex;\n  uniform sampler2D starting_knn_tex;\n  uniform float num_points;\n  uniform float points_per_row_knn;\n  uniform float num_rows_knn;\n  uniform float num_neighs;\n  uniform float iteration;\n\n  //output\n  //the indices are packed in varying vectors\n  flat out vec4 knn[NUM_PACKED_NEIGHBORS];\n  //used to recover the neighbor id in the fragment shader\n  out float neighbor_id;\n  //used to recover the point id in the fragment shader\n  //(for recomputing distances)\n  flat out int point_id;\n\n  float distances_heap[NUM_NEIGHBORS];\n  int knn_heap[NUM_NEIGHBORS];\n  "}var d="\n//Random function developed by Inigo Quilez\n//https://www.shadertoy.com/view/llGSzw\nfloat hash1( uint n ) {\n    // integer hash copied from Hugo Elias\n\t  n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\nfloat random( float f ) {\n    const uint mantissaMask = 0x007FFFFFu;\n    const uint one          = 0x3F800000u;\n\n    uint h = hash( floatBitsToUint( f ) );\n    h &= mantissaMask;\n    h |= one;\n\n    float  r2 = uintBitsToFloat( h );\n    return r2 - 1.0;\n}\n\n\n// #define HASHSCALE1 .1031\n// float random(float p) {\n// \tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n//   p3 += dot(p3, p3.yzx + 19.19);\n//   return fract((p3.x + p3.y) * p3.z);\n// }\n\n// const vec2 randomConst = vec2(\n//   23.14069263277926, // e^pi (Gelfond's constant)\n//    2.665144142690225 // 2^sqrt(2) (Gelfondâ€“Schneider constant)\n// );\n// float random(float seed) {\n//     return fract(cos(dot(vec2(seed,seed), randomConst)) * 12345.6789);\n// }\n\n",f="\n//Reads the distances and indices from the knn texture\nvoid initializeDistances(int pnt_id) {\n  //row coordinate in the texture\n  float row = (floor(float(pnt_id)/points_per_row_knn)+0.5)/num_rows_knn;\n  //column of the first neighbor\n  float start_col = mod(float(pnt_id),points_per_row_knn)*NUM_NEIGHBORS_FLOAT;\n  for(int n = 0; n < NUM_NEIGHBORS; n++) {\n    float col = (start_col+float(n)+0.5);\n    //normalized by the width of the texture\n    col /= (points_per_row_knn*NUM_NEIGHBORS_FLOAT);\n    //reads the index in the red channel and the distances in the green one\n    vec4 init = texture(starting_knn_tex,vec2(col,row));\n\n    knn_heap[n] = int(init.r);\n    distances_heap[n] = init.g;\n  }\n}\n",_="\n//Swaps two points in the knn-heap\nvoid swap(int i, int j) {\n  float swap_value = distances_heap[i];\n  distances_heap[i] = distances_heap[j];\n  distances_heap[j] = swap_value;\n  int swap_id = knn_heap[i];\n  knn_heap[i] = knn_heap[j];\n  knn_heap[j] = swap_id;\n}\n\n//I can make use of the heap property but\n//I have to implement a recursive function\nbool inTheHeap(float dist_sq, int id) {\n  for(int i = 0; i < NUM_NEIGHBORS; ++i) {\n    if(knn_heap[i] == id) {\n      return true;\n    }\n  }\n  return false;\n}\n\nvoid insertInKNN(float dist_sq, int j) {\n  //not in the KNN\n  if(dist_sq >= distances_heap[0]) {\n    return;\n  }\n\n  //the point is already in the KNN\n  if(inTheHeap(dist_sq,j)) {\n    return;\n  }\n\n  //Insert in the new point in the root\n  distances_heap[0] = dist_sq;\n  knn_heap[0] = j;\n  //Sink procedure\n  int swap_id = 0;\n  while(swap_id*2+1 < NUM_NEIGHBORS) {\n    int left_id = swap_id*2+1;\n    int right_id = swap_id*2+2;\n    if(distances_heap[left_id] > distances_heap[swap_id] ||\n        (right_id < NUM_NEIGHBORS &&\n                            distances_heap[right_id] > distances_heap[swap_id])\n      ) {\n      if(distances_heap[left_id] > distances_heap[right_id]\n         || right_id >= NUM_NEIGHBORS) {\n        swap(swap_id,left_id);\n        swap_id = left_id;\n      }else{\n        swap(swap_id,right_id);\n        swap_id = right_id;\n      }\n    }else{\n      break;\n    }\n  }\n}\n",c="\n  //Line positions\n  float row = (floor(float(point_id)/points_per_row_knn)+0.5)/num_rows_knn;\n  row = row*2.0-1.0;\n  if(line_id < int(1)) {\n    //for the first vertex only the position is important\n    float col = (mod(float(point_id),points_per_row_knn))/(points_per_row_knn);\n    col = col*2.0-1.0;\n    gl_Position = vec4(col,row,0,1);\n    neighbor_id = 0.;\n    return;\n  }\n  //The computation of the KNN happens only for the second vertex\n  float col = (mod(float(point_id),points_per_row_knn)+1.)/(points_per_row_knn);\n  col = col*2.0-1.0;\n  gl_Position = vec4(col,row,0,1);\n";function o(t,n,e,i,o,r,a,s){var l=t.gl,u=t.program,h=l.getParameter(l.LINE_WIDTH);null!=s?t.setOutputMatrixTexture(s,r.numRows,r.pointsPerRow*r.pixelsPerPoint):C.webgl.webgl_util.bindCanvasToFramebuffer(t.gl),1!==h&&l.lineWidth(1),t.setProgram(n),l.clearColor(0,0,0,0),l.clear(l.COLOR_BUFFER_BIT),C.webgl.webgl_util.callAndCheck(l,function(){return l.bindBuffer(l.ARRAY_BUFFER,a)}),C.webgl.webgl_util.bindVertexBufferToProgramAttribute(l,n,"vertex_id",a,1,0,0);s=C.webgl.webgl_util.getProgramUniformLocationOrThrow(l,n,"data_tex");t.setInputMatrixTexture(e,s,0);s=C.webgl.webgl_util.getProgramUniformLocationOrThrow(l,n,"starting_knn_tex");t.setInputMatrixTexture(i,s,1);s=C.webgl.webgl_util.getProgramUniformLocationOrThrow(l,n,"iteration");l.uniform1f(s,o);o=C.webgl.webgl_util.getProgramUniformLocationOrThrow(l,n,"num_points");l.uniform1f(o,r.numPoints);o=C.webgl.webgl_util.getProgramUniformLocationOrThrow(l,n,"points_per_row_knn");l.uniform1f(o,r.pointsPerRow);n=C.webgl.webgl_util.getProgramUniformLocationOrThrow(l,n,"num_rows_knn");l.uniform1f(n,r.numRows),C.webgl.webgl_util.callAndCheck(l,function(){return l.drawArrays(l.LINES,0,2*r.numPoints)}),null!=u&&(t.setProgram(u),C.webgl.gpgpu_util.bindVertexProgramAttributeStreams(t.gl,u,t.vertexBuffer)),1!==h&&l.lineWidth(h)}function U(t){return t.createProgram("\n    precision highp float;\n    uniform sampler2D knn_tex;\n    uniform float width;\n    uniform float height;\n\n    void main() {\n      vec2 coordinates = gl_FragCoord.xy / vec2(width,height);\n      float distance = texture2D(knn_tex,coordinates).g;\n      gl_FragColor = vec4(distance,0,0,1);\n    }\n  ")}function F(t,n,e,i,o){var r=t.gl;null!=o?t.setOutputMatrixTexture(o,i.numRows,i.pointsPerRow*i.pixelsPerPoint):C.webgl.webgl_util.bindCanvasToFramebuffer(t.gl),t.setProgram(n);o=C.webgl.webgl_util.getProgramUniformLocationOrThrow(r,n,"knn_tex");t.setInputMatrixTexture(e,o,0);o=C.webgl.webgl_util.getProgramUniformLocationOrThrow(r,n,"width");r.uniform1f(o,i.pointsPerRow*i.pixelsPerPoint);n=C.webgl.webgl_util.getProgramUniformLocationOrThrow(r,n,"height");r.uniform1f(n,i.numRows),t.executeProgram()}function G(t){return t.createProgram("\n    precision highp float;\n    uniform sampler2D knn_tex;\n    uniform float width;\n    uniform float height;\n\n    void main() {\n      vec2 coordinates = gl_FragCoord.xy / vec2(width,height);\n      float id = texture2D(knn_tex,coordinates).r;\n      gl_FragColor = vec4(id,0,0,1);\n\n      if(id < 0.) {\n        gl_FragColor.b = 1.;\n      }\n    }\n  ")}function L(t,n,e,i,o){var r=t.gl;null!=o?t.setOutputMatrixTexture(o,i.numRows,i.pointsPerRow*i.pixelsPerPoint):C.webgl.webgl_util.bindCanvasToFramebuffer(t.gl),t.setProgram(n);o=C.webgl.webgl_util.getProgramUniformLocationOrThrow(r,n,"knn_tex");t.setInputMatrixTexture(e,o,0);o=C.webgl.webgl_util.getProgramUniformLocationOrThrow(r,n,"width");r.uniform1f(o,i.pointsPerRow*i.pixelsPerPoint);n=C.webgl.webgl_util.getProgramUniformLocationOrThrow(r,n,"height");r.uniform1f(n,i.numRows),t.executeProgram()}var b=(Object.defineProperty(n.prototype,"knnShape",{get:function(){return this.knnDataShape},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"iteration",{get:function(){return this._iteration},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"pointsPerIteration",{get:function(){return 20},enumerable:!0,configurable:!0}),n.prototype.log=function(t,n){this.verbose&&(null!=n?console.log(t+": \t"+n):console.log(t))},n.prototype.initializeTextures=function(){for(var t=new Float32Array(this.knnDataShape.pointsPerRow*this.knnDataShape.pixelsPerPoint*2*this.knnDataShape.numRows),n=this.knnDataShape.pixelsPerPoint,e=0;e<this.knnDataShape.numPoints;++e)for(var i=0;i<n;++i)t[2*(e*n+i)]=-1,t[2*(e*n+i)+1]=1e31;this.log("knn-textureWidth",this.knnDataShape.pointsPerRow*this.knnDataShape.pixelsPerPoint),this.log("knn-textureHeight",this.knnDataShape.numRows),this.knnTexture0=M(this.gpgpu.gl,this.knnDataShape.pointsPerRow*this.knnDataShape.pixelsPerPoint,this.knnDataShape.numRows,2,t),this.knnTexture1=M(this.gpgpu.gl,this.knnDataShape.pointsPerRow*this.knnDataShape.pixelsPerPoint,this.knnDataShape.numRows,2,t)},n.prototype.initilizeCustomWebGLPrograms=function(t){var n,e,i,o;this.log("knn Create programs/buffers start"),this.copyDistancesProgram=U(this.gpgpu),this.log("knn Create indices program"),this.copyIndicesProgram=G(this.gpgpu),this.log("knn Create brute force knn program, numNeighs",this.numNeighs),this.bruteForceKNNProgram=(o=this.gpgpu,i=this.numNeighs,n="#version 300 es\n    "+m(i)+f+(e=t)+_+"\n    void main() {\n      //Getting the id of the point and the line id (0/1)\n      point_id = int((vertex_id / 2.0) + 0.1);\n      int line_id = int(mod(vertex_id + 0.1, 2.));\n      if(float(point_id) >= num_points) {\n        return;\n      }\n\n      "+c+"\n\n      //////////////////////////////////\n      //KNN computation\n      initializeDistances(point_id);\n      for(int i = 0; i < NEIGH_PER_ITER; i += 4) {\n        //TODO make it more readable\n\n        int j = int(mod(\n                    float(point_id + i) //point id + current offset\n                    + iteration * float(NEIGH_PER_ITER) //iteration offset\n                    + 1.25,// +1 for avoid checking the point itself,\n                           // +0.25 for error compensation\n                    num_points\n                  ));\n        vec4 dist_squared = pointDistanceSquaredBatch(point_id,j,j+1,j+2,j+3);\n        insertInKNN(dist_squared.r, j);\n        insertInKNN(dist_squared.g, j+1);\n        insertInKNN(dist_squared.b, j+2);\n        insertInKNN(dist_squared.a, j+3);\n      }\n\n      for(int n = 0; n < NUM_PACKED_NEIGHBORS; n++) {\n        knn[n].r = float(knn_heap[n*4]);\n        knn[n].g = float(knn_heap[n*4+1]);\n        knn[n].b = float(knn_heap[n*4+2]);\n        knn[n].a = float(knn_heap[n*4+3]);\n      }\n\n      neighbor_id = NUM_NEIGHBORS_FLOAT;\n    }\n  ",i=p(e,i),s(o.gl,n,i)),this.log("knn Create random sampling force knn program"),this.randomSamplingKNNProgram=(e=this.gpgpu,o=this.numNeighs,i="#version 300 es\n    "+m(o)+f+d+(n=t)+_+"\n    void main() {\n      //Getting the id of the point and the line id (0/1)\n      point_id = int((vertex_id/2.0)+0.1);\n      int line_id = int(mod(vertex_id+0.1,2.));\n      if(float(point_id) >= num_points) {\n        return;\n      }\n\n      "+c+"\n\n      //////////////////////////////////\n      //KNN computation\n\n      initializeDistances(point_id);\n      for(int i = 0; i < NEIGH_PER_ITER; i += 4) {\n        //BAD SEED\n        //uint seed\n        //= uint(float(point_id) + float(NEIGH_PER_ITER)*iteration + float(i));\n        //GOOD SEED\n        //uint seed\n        //= uint(float(point_id) + float(num_points)*iteration + float(i));\n\n        float seed\n            = float(float(point_id) + float(num_points)*iteration + float(i));\n        int j0 = int(random(seed)*num_points);\n        int j1 = int(random(seed+1.)*num_points);\n        int j2 = int(random(seed+2.)*num_points);\n        int j3 = int(random(seed+3.)*num_points);\n\n        vec4 dist_squared = pointDistanceSquaredBatch(point_id,j0,j1,j2,j3);\n        if(j0!=point_id)insertInKNN(dist_squared.r, j0);\n        if(j1!=point_id)insertInKNN(dist_squared.g, j1);\n        if(j2!=point_id)insertInKNN(dist_squared.b, j2);\n        if(j3!=point_id)insertInKNN(dist_squared.a, j3);\n      }\n\n      for(int n = 0; n < NUM_PACKED_NEIGHBORS; n++) {\n        knn[n].r = float(knn_heap[n*4]);\n        knn[n].g = float(knn_heap[n*4+1]);\n        knn[n].b = float(knn_heap[n*4+2]);\n        knn[n].a = float(knn_heap[n*4+3]);\n      }\n      neighbor_id = NUM_NEIGHBORS_FLOAT;\n    }\n  ",o=p(n,o),s(e.gl,i,o)),this.log("knn Create descent program"),this.kNNDescentProgram=(e=this.gpgpu,i=this.numNeighs,t="#version 300 es\n    "+m(i)+f+d+(o=t)+_+"\n    int fetchNeighborIdFromKNNTexture(int id, int neighbor_id) {\n      //row coordinate in the texture\n      float row = (floor(float(id)/points_per_row_knn)+0.5)/num_rows_knn;\n      //column of the first neighbor\n      float start_col = mod(float(id),points_per_row_knn)*NUM_NEIGHBORS_FLOAT;\n      //column of the neighbor of interest\n      float col = (start_col+float(neighbor_id)+0.5);\n      //normalized by the width of the texture\n      col /= (points_per_row_knn*NUM_NEIGHBORS_FLOAT);\n      //reads the index in the red channel and the distances in the green one\n      vec4 knn_link = texture(starting_knn_tex,vec2(col,row));\n      //return the index\n      return int(knn_link.r);\n    }\n\n    int neighborOfANeighbor(int my_id, uint seed) {\n      //float random0 = hash1(seed);\n      float random0 = random(float(seed));\n      // random0 = random0*random0;\n      // random0 = 1. - random0;\n\n      //float random1 = hash1(seed*1798191U);\n      float random1 = random(float(seed+7U));\n      // random1 = random1*random1;\n      // random1 = 1. - random1;\n\n      //fetch a neighbor from the heap\n      int neighbor = knn_heap[int(random0*NUM_NEIGHBORS_FLOAT)];\n      //if it is not a valid pick a random point\n      if(neighbor < 0) {\n        return int(random(float(seed))*num_points);\n      }\n\n      //if it is valid I fetch from the knn graph texture one of its neighbors\n      int neighbor2ndDegree = fetchNeighborIdFromKNNTexture(\n                                    neighbor,int(random1*NUM_NEIGHBORS_FLOAT));\n      //if it is not a valid pick a random point\n      if(neighbor2ndDegree < 0) {\n        return int(random(float(seed))*num_points);\n      }\n      return neighbor2ndDegree;\n    }\n\n    void main() {\n      //Getting the id of the point and the line id (0/1)\n      point_id = int((vertex_id/2.0)+0.1);\n      int line_id = int(mod(vertex_id+0.1,2.));\n      if(float(point_id) >= num_points) {\n        return;\n      }\n      "+c+"\n\n      //////////////////////////////////\n      //KNN computation\n      initializeDistances(point_id);\n      for(int i = 0; i < NEIGH_PER_ITER; i += 4) {\n        //BAD SEED\n        //uint seed\n        //= uint(float(point_id) + float(NEIGH_PER_ITER)*iteration + float(i));\n        //GOOD SEED\n        uint seed\n              = uint(float(point_id) + float(num_points)*iteration + float(i));\n        int j0 = neighborOfANeighbor(point_id,seed);\n        int j1 = neighborOfANeighbor(point_id,seed+1U);\n        int j2 = neighborOfANeighbor(point_id,seed+2U);\n        int j3 = neighborOfANeighbor(point_id,seed+3U);\n\n        vec4 dist_squared = pointDistanceSquaredBatch(point_id,j0,j1,j2,j3);\n        if(j0!=point_id)insertInKNN(dist_squared.r, j0);\n        if(j1!=point_id)insertInKNN(dist_squared.g, j1);\n        if(j2!=point_id)insertInKNN(dist_squared.b, j2);\n        if(j3!=point_id)insertInKNN(dist_squared.a, j3);\n      }\n\n      for(int n = 0; n < NUM_PACKED_NEIGHBORS; n++) {\n        knn[n].r = float(knn_heap[n*4]);\n        knn[n].g = float(knn_heap[n*4+1]);\n        knn[n].b = float(knn_heap[n*4+2]);\n        knn[n].a = float(knn_heap[n*4+3]);\n      }\n      neighbor_id = NUM_NEIGHBORS_FLOAT;\n    }\n  ",i=p(o,i),s(e.gl,t,i));for(var r=new Float32Array(2*this.knnDataShape.numPoints),a=0;a<2*this.knnDataShape.numPoints;++a)r[a]=a;this.log("knn Create static vertex start"),this.linesVertexIdBuffer=C.webgl.webgl_util.createStaticVertexBuffer(this.gpgpu.gl,r),this.log("knn Create programs/buffers done")},n.prototype.iterateBruteForce=function(){this._iteration%2==0?this.iterateGPU(this.dataTexture,this._iteration,this.knnTexture0,this.knnTexture1):this.iterateGPU(this.dataTexture,this._iteration,this.knnTexture1,this.knnTexture0),++this._iteration,this.gpgpu.gl.finish()},n.prototype.iterateRandomSampling=function(){this._iteration%2==0?this.iterateRandomSamplingGPU(this.dataTexture,this._iteration,this.knnTexture0,this.knnTexture1):this.iterateRandomSamplingGPU(this.dataTexture,this._iteration,this.knnTexture1,this.knnTexture0),++this._iteration,this.gpgpu.gl.finish()},n.prototype.iterateKNNDescent=function(){this._iteration%2==0?this.iterateKNNDescentGPU(this.dataTexture,this._iteration,this.knnTexture0,this.knnTexture1):this.iterateKNNDescentGPU(this.dataTexture,this._iteration,this.knnTexture1,this.knnTexture0),++this._iteration,this.gpgpu.gl.finish()},n.prototype.knn=function(){return this._iteration%2==0?this.knnTexture0:this.knnTexture1},n.prototype.distancesTensor=function(){var e=this;return C.tidy(function(){var t=C.zeros([e.knnDataShape.numRows,e.knnDataShape.pointsPerRow*e.knnDataShape.pixelsPerPoint]),n=e.knn();return F(e.gpgpu,e.copyDistancesProgram,n,e.knnDataShape,e.backend.getTexture(t.dataId)),t.reshape([e.knnDataShape.numRows*e.knnDataShape.pointsPerRow,e.knnDataShape.pixelsPerPoint]).slice([0,0],[e.knnDataShape.numPoints,e.knnDataShape.pixelsPerPoint])})},n.prototype.indicesTensor=function(){var e=this;return C.tidy(function(){var t=C.zeros([e.knnDataShape.numRows,e.knnDataShape.pointsPerRow*e.knnDataShape.pixelsPerPoint]),n=e.knn();return L(e.gpgpu,e.copyIndicesProgram,n,e.knnDataShape,e.backend.getTexture(t.dataId)),t.reshape([e.knnDataShape.numRows*e.knnDataShape.pointsPerRow,e.knnDataShape.pixelsPerPoint]).slice([0,0],[e.knnDataShape.numPoints,e.knnDataShape.pixelsPerPoint])})},n.prototype.forceSync=function(){this.downloadTextureToMatrix(this.knnTexture0)},n.prototype.downloadTextureToMatrix=function(t){return this.gpgpu.downloadFloat32MatrixFromOutputTexture(t,this.knnDataShape.numRows,this.knnDataShape.pointsPerRow*this.knnDataShape.pixelsPerPoint)},n.prototype.iterateGPU=function(t,n,e,i){o(this.gpgpu,this.bruteForceKNNProgram,t,e,n,this.knnDataShape,this.linesVertexIdBuffer,i)},n.prototype.iterateRandomSamplingGPU=function(t,n,e,i){o(this.gpgpu,this.randomSamplingKNNProgram,t,e,n,this.knnDataShape,this.linesVertexIdBuffer,i)},n.prototype.iterateKNNDescentGPU=function(t,n,e,i){o(this.gpgpu,this.kNNDescentProgram,t,e,n,this.knnDataShape,this.linesVertexIdBuffer,i)},n);function n(t,n,e,i,o,r){if(null!=r?this.verbose=r:r=!1,this.backend=C.ENV.findBackend("webgl"),this.gpgpu=this.backend.getGPGPUContext(),this._iteration=0,this.dataTexture=t,128<o)throw new Error("kNN size must not be greater than 128");if(o%4!=0)throw new Error("kNN size must be a multiple of 4");this.numNeighs=o;var a,t=Math.ceil(Math.sqrt(o*e)/o);this.knnDataShape={numPoints:e,pixelsPerPoint:o,pointsPerRow:t,numRows:Math.ceil(e/t)},this.log("knn-pntsPerRow",this.knnDataShape.pointsPerRow),this.log("knn-numRows",this.knnDataShape.numRows),this.log("knn-pixelsPerPoint",this.knnDataShape.pixelsPerPoint),"numPoints"in(t=n)&&"pointsPerRow"in t&&"pixelsPerPoint"in t&&"numRows"in t?a="\n    #define DATA_NUM_PACKED_DIMENSIONS "+(a=n).pixelsPerPoint+".\n    #define DATA_POINTS_PER_ROW "+a.pointsPerRow+".\n    #define DATA_NUM_ROWS "+a.numRows+".\n    #define TEXTURE_WIDTH "+a.pointsPerRow*a.pixelsPerPoint+".\n\n    //returns the texture coordinate for point/dimension\n    vec2 dataTexCoordinates(int id, int dimension) {\n      float id_f = float(id);\n      float row = (floor(id_f/DATA_POINTS_PER_ROW)+0.5) / DATA_NUM_ROWS;\n      float col = ((mod(id_f,DATA_POINTS_PER_ROW)*(DATA_NUM_PACKED_DIMENSIONS)\n                  + float(dimension)) + 0.5) / (TEXTURE_WIDTH);\n      return vec2(col,row);\n    }\n\n    //compute the euclidean squared distances between two points i and j\n    float pointDistanceSquared(int i, int j) {\n      vec4 result = vec4(0,0,0,0);\n      int num_iter = int(DATA_NUM_PACKED_DIMENSIONS);\n      for(int d = 0; d < num_iter; ++d) {\n        vec4 vi = texture(data_tex,dataTexCoordinates(i,d));\n        vec4 vj = texture(data_tex,dataTexCoordinates(j,d));\n        result += (vi-vj)*(vi-vj);\n      }\n      return (result.r+result.g+result.b+result.a);\n    }\n\n    //compute the euclidean squared distances between two points i and j\n    vec4 pointDistanceSquaredBatch(int i, int j0, int j1, int j2, int j3) {\n      vec4 result = vec4(0,0,0,0);\n      int num_iter = int(DATA_NUM_PACKED_DIMENSIONS);\n      for(int d = 0; d < num_iter; ++d) {\n        vec4 vi = texture(data_tex,dataTexCoordinates(i,d));\n        vec4 vj0 = texture(data_tex,dataTexCoordinates(j0,d));\n        vec4 vj1 = texture(data_tex,dataTexCoordinates(j1,d));\n        vec4 vj2 = texture(data_tex,dataTexCoordinates(j2,d));\n        vec4 vj3 = texture(data_tex,dataTexCoordinates(j3,d));\n        vj0 = (vi-vj0); vj0 *= vj0;\n        vj1 = (vi-vj1); vj1 *= vj1;\n        vj2 = (vi-vj2); vj2 *= vj2;\n        vj3 = (vi-vj3); vj3 *= vj3;\n        result.r += (vj0.r+vj0.g+vj0.b+vj0.a);\n        result.g += (vj1.r+vj1.g+vj1.b+vj1.a);\n        result.b += (vj2.r+vj2.g+vj2.b+vj2.a);\n        result.a += (vj3.r+vj3.g+vj3.b+vj3.a);\n      }\n      return result;\n    }\n    ":"distanceComputationCode"in n&&(a=n.distanceComputationCode),this.initializeTextures(),this.initilizeCustomWebGLPrograms(a)}function x(r,a,s,l){return new(s=s||Promise)(function(t,n){function e(t){try{o(l.next(t))}catch(t){n(t)}}function i(t){try{o(l.throw(t))}catch(t){n(t)}}function o(n){n.done?t(n.value):new s(function(t){t(n.value)}).then(e,i)}o((l=l.apply(r,a||[])).next())})}function z(e,i){var o,r,a,s={label:0,sent:function(){if(1&a[0])throw a[1];return a[1]},trys:[],ops:[]},t={next:n(0),throw:n(1),return:n(2)};return"function"==typeof Symbol&&(t[Symbol.iterator]=function(){return this}),t;function n(n){return function(t){return function(n){if(o)throw new TypeError("Generator is already executing.");for(;s;)try{if(o=1,r&&(a=2&n[0]?r.return:n[0]?r.throw||((a=r.return)&&a.call(r),0):r.next)&&!(a=a.call(r,n[1])).done)return a;switch(r=0,(n=a?[2&n[0],a.value]:n)[0]){case 0:case 1:a=n;break;case 4:return s.label++,{value:n[1],done:!1};case 5:s.label++,r=n[1],n=[0];continue;case 7:n=s.ops.pop(),s.trys.pop();continue;default:if(!(a=0<(a=s.trys).length&&a[a.length-1])&&(6===n[0]||2===n[0])){s=0;continue}if(3===n[0]&&(!a||n[1]>a[0]&&n[1]<a[3])){s.label=n[1];break}if(6===n[0]&&s.label<a[1]){s.label=a[1],a=n;break}if(a&&s.label<a[2]){s.label=a[2],s.ops.push(n);break}a[2]&&s.ops.pop(),s.trys.pop();continue}n=i.call(e,s)}catch(t){n=[6,t],r=0}finally{o=a=0}if(5&n[0])throw n[1];return{value:n[0]?n[1]:void 0,done:!0}}([n,t])}}}function B(t,n){var e="function"==typeof Symbol&&t[Symbol.iterator];if(!e)return t;var i,o,r=e.call(t),a=[];try{for(;(void 0===n||0<n--)&&!(i=r.next()).done;)a.push(i.value)}catch(t){o={error:t}}finally{try{i&&!i.done&&(e=r.return)&&e.call(r)}finally{if(o)throw o.error}}return a}var w=(Object.defineProperty(e.prototype,"minX",{get:function(){return this._minX},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"maxX",{get:function(){return this._maxX},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"minY",{get:function(){return this._minY},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"maxY",{get:function(){return this._maxY},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"iteration",{get:function(){return this._iteration},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"numberOfPoints",{get:function(){return this.numPoints},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"numberOfPointsPerRow",{get:function(){return this.pointsPerRow},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"numberOfRows",{get:function(){return this.numRows},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"embeddingCoordinates",{get:function(){return this.embedding},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"embedding2D",{get:function(){var t=this;return C.tidy(function(){return t.embedding.reshape([t.numRows*t.pointsPerRow,2]).slice([0,0],[t.numPoints,2])})},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"embeddingTexture",{get:function(){return this.backend.getTexture(this.embedding.dataId)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"splatTexture",{get:function(){return this._splatTexture},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"normalizationQ",{get:function(){return this._normQ},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"exaggerationAtCurrentIteration",{get:function(){return this._exaggeration.get()},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"exaggeration",{get:function(){return this.rawExaggeration},set:function(t){if("number"==typeof(this.rawExaggeration=t)){if(t<1)throw Error("Exaggeration must be greater then or equal to one")}else{for(var n=0;n<t.length;++n){if(t[n].value<1)throw Error("Exaggeration must be greater then or equal to one");if(t[n].iteration<0)throw Error("Piecewise linear exaggeration function                                         must have poistive iteration values")}for(n=0;n<t.length-1;++n)if(t[n].iteration>=t[n+1].iteration)throw Error("Piecewise linear exaggeration function                                       must have increasing iteration values");1===t.length&&(this.exaggeration=t[0].value)}this.updateExaggeration()},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"momentum",{get:function(){return this._momentum.get()},set:function(t){if(t<0||1<t)throw Error("Momentum must be in the [0,1] range");this._momentum.dispose(),this._momentum=C.scalar(t)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"applyGain",{get:function(){return this._applyGain},set:function(t){this._applyGain=t},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"eta",{get:function(){return this._eta},set:function(t){if(t<=0)throw Error("ETA must be greater then zero");this._eta=t},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"spacePerPixel",{get:function(){return this._spacePerPixel},set:function(t){if(t<=0)throw Error("Space Per Pixel must be greater then zero");this._spacePerPixel=t},enumerable:!0,configurable:!0}),e.prototype.dispose=function(){this.embedding.dispose(),this.gradient.dispose(),this.gain.dispose(),this.minGain.dispose(),this._momentum.dispose(),this._exaggeration.dispose(),this.gpgpu.gl.deleteTexture(this._splatTexture),this.gpgpu.gl.deleteTexture(this.kernelTexture),null!=this.kernelTexture&&this.gpgpu.gl.deleteTexture(this.probOffsetTexture),null!=this.kernelTexture&&this.gpgpu.gl.deleteTexture(this.probNeighIdTexture),null!=this.kernelTexture&&this.gpgpu.gl.deleteTexture(this.probTexture),this.gpgpu.gl.deleteBuffer(this.splatVertexIdBuffer),this.gpgpu.gl.deleteProgram(this.embeddingInitializationProgram),this.gpgpu.gl.deleteProgram(this.embeddingSplatterProgram),this.gpgpu.gl.deleteProgram(this.qInterpolatorProgram),this.gpgpu.gl.deleteProgram(this.xyInterpolatorProgram),this.gpgpu.gl.deleteProgram(this.attractiveForcesProgram),this.gpgpu.gl.deleteProgram(this.distributionParameterssComputationProgram),this.gpgpu.gl.deleteProgram(this.gaussiaDistributionsFromDistancesProgram)},e.prototype.initializeEmbedding=function(){var e=this;null!=this.embedding&&this.embedding.dispose(),null!=this.gradient&&this.gradient.dispose(),null!=this.gain&&this.gain.dispose(),null!=this.minGain&&this.minGain.dispose(),this.gradient=C.zeros([this.numRows,2*this.pointsPerRow]),this.gain=C.ones([this.numRows,2*this.pointsPerRow]),this.minGain=C.ones([this.numRows,2*this.pointsPerRow]).mul(C.scalar(this._minimumGain)),this.embedding=C.tidy(function(){var t=C.randomUniform([e.numRows,2*e.pointsPerRow]),n=C.zeros([e.numRows,2*e.pointsPerRow]);return e.initializeEmbeddingPositions(n,t),n.mul(C.scalar(.1))});this._minX=-3,this._minY=-3,this._maxX=3,this._maxY=3,this.log("\tmin X",this._minX),this.log("\tmax X",this._maxX),this.log("\tmin Y",this._minY),this.log("\tmax Y",this._maxY),this._iteration=0},e.prototype.initializeNeighbors=function(t,n,e,i){this.numNeighPerRow=t,this.probOffsetTexture=n,this.probTexture=e,this.probNeighIdTexture=i},e.prototype.initializeNeighborsFromKNNGraph=function(l,u,h,g,p){return x(this,void 0,void 0,function(){var n,e,i,o,r,a,s;return z(this,function(t){switch(t.label){case 0:for(n=Math.max(1,Math.floor(Math.sqrt(l*u)/u)),s=Math.ceil(l/n),e={numPoints:l,pixelsPerPoint:u,numRows:s,pointsPerRow:n},i=new Float32Array(n*u*s*2),o=0;o<l;++o)for(r=0;r<u;++r)i[2*(a=o*u+r)]=g[a],i[2*a+1]=h[a];return s=M(this.gpgpu.gl,n*u,s,2,i),[4,this.initializeNeighborsFromKNNTexture(e,s,p)];case 1:return t.sent(),this.gpgpu.gl.deleteTexture(s),[2]}})})},e.prototype.pairFunction=function(t,n){return(t+n)*(t+n+1)/2},e.prototype.initializeNeighborsFromKNNTexture=function(S,A,j){return x(this,void 0,void 0,function(){var n,e,i,o,r,a,s,l,u,h,g,p,m,d,f,_,c,b,x,w,P,v,T,k,y,N,E,R,D,O,I;return z(this,function(t){switch(t.label){case 0:if(this.log("Asymmetric neighborhood initialization..."),S.numPoints!==this.numPoints)throw new Error("KNN size and number of points must agree("+S.numPoints+","+this.numPoints+")");return this.log("Shape info: pixelsPerPoint "+S.pixelsPerPoint),this.log("Create distribution params texture: \n        pointsPerRow: "+S.pointsPerRow+" x numRows: "+S.numRows),a=M(this.gpgpu.gl,S.pointsPerRow,S.numRows,2),this.log("Create zeroed distribution tensor"),n=C.zeros([S.numRows,S.pointsPerRow*S.pixelsPerPoint]),this.gpgpu.enableAutomaticDebugValidation(!0),this.log("Computing distribution params"),this.computeDistributionParameters(a,S,j,A),console.log("Perplexity: "+j),this.log("Computing Gaussian distn"),this.computeGaussianDistributions(n,a,S,A),this.log("Retrieve Gaussian distn"),e=n.dataSync(),i=C.zeros([S.numRows,S.pointsPerRow*S.pixelsPerPoint]),this.log("Create copy indices program",i.shape),o=G(this.gpgpu),this.log("Execute copy indices program",i.shape),L(this.gpgpu,o,A,S,this.backend.getTexture(i.dataId)),a=C.zeros([S.numRows,S.pointsPerRow*S.pixelsPerPoint]),o=U(this.gpgpu),F(this.gpgpu,o,A,S,this.backend.getTexture(a.dataId)),[4,i.data()];case 1:return r=t.sent(),[4,a.data()];case 2:for(a=t.sent(),this.log("Type of knnIndicesData "+r.constructor.name),this.log("knn Indices",r),this.log("knn Distances",a),s=new Uint32Array(S.numPoints*S.pixelsPerPoint),y=0;y<this.numPoints;++y)for(l=0;l<S.pixelsPerPoint;++l)E=y*S.pixelsPerPoint+l,s[y*S.pixelsPerPoint+l]=r[E];for(u=[],y=0;y<S.numPoints;++y)g=y*S.pixelsPerPoint,u.push(function(){for(var t=[],n=0;n<arguments.length;n++)t=t.concat(B(arguments[n]));return t}(s.slice(g,g+S.pixelsPerPoint)));for(h=[],y=0;y<S.numPoints;++y)for(N=0;N<S.pixelsPerPoint;++N)g=y*S.pixelsPerPoint+N,p=s[g],-1<(m=u[p].indexOf(y))&&(m=p*S.pixelsPerPoint+m,h[this.pairFunction(p,y)]=e[m]);for(this.log("Neig - point prob"),d=new Uint32Array(this.numPoints),f=new Uint32Array(this.numPoints),y=0;y<S.numPoints*S.pixelsPerPoint;++y)++d[s[y]];for(y=1;y<S.numPoints;++y)f[y]=f[y-1]+S.pixelsPerPoint+d[y-1];for(this.log("Counter",d),this.log("Linear offset",f),y=b=c=_=0;y<d.length;++y)_+=d[y],d[y]>c&&(c=d[y],b=y);for(this.log("Number of indirect links",_),this.log("Most central point",b),this.log("Number of indirect links for the central point",c),this.numNeighPerRow=Math.ceil(Math.sqrt(S.numPoints*S.pixelsPerPoint*2)),this.log("numNeighPerRow",this.numNeighPerRow),x=new Float32Array(this.pointsPerRow*this.numRows*3),y=w=0;y<this.numPoints;++y)P=S.pixelsPerPoint+d[y],x[3*y+0]=w%this.numNeighPerRow,x[3*y+1]=Math.floor(w/this.numNeighPerRow),x[3*y+2]=P,w+=P;for(this.log("Offsets",x),this.probOffsetTexture=M(this.gpgpu.gl,this.pointsPerRow,this.numRows,3,x),v=new Float32Array(this.numNeighPerRow*this.numNeighPerRow),T=new Float32Array(this.numNeighPerRow*this.numNeighPerRow),k=new Uint32Array(this.numPoints),y=0;y<this.numPoints;++y)for(N=0;N<S.pixelsPerPoint;++N)E=y*S.pixelsPerPoint+N,R=r[E],I=e[E],O=h[this.pairFunction(R,y)],D=((O=O||0)+I)/2,O=f[y]+N,I=f[R]+S.pixelsPerPoint+k[R],v[O]=D,v[I]=D,T[O]=R,T[I]=y,++k[R];return this.probTexture=M(this.gpgpu.gl,this.numNeighPerRow,this.numNeighPerRow,1,v),this.probNeighIdTexture=M(this.gpgpu.gl,this.numNeighPerRow,this.numNeighPerRow,1,T),n.dispose(),i.dispose(),this.log("...done!"),[2]}})})},e.prototype.initializedNeighborhoods=function(){return null!=this.probNeighIdTexture},e.prototype.updateExaggeration=function(){if(void 0!==this._exaggeration&&this._exaggeration.dispose(),"number"!=typeof this.rawExaggeration){if(this._iteration<=this.rawExaggeration[0].iteration)return this._exaggeration=C.scalar(this.rawExaggeration[0].value),void this.log("Exaggeration val: "+this.rawExaggeration[0].value);if(this._iteration>=this.rawExaggeration[this.rawExaggeration.length-1].iteration)return this._exaggeration=C.scalar(this.rawExaggeration[this.rawExaggeration.length-1].value),void this.log("Exaggeration val: \n        "+this.rawExaggeration[this.rawExaggeration.length-1].value);for(var t=0;t<this.rawExaggeration.length&&this._iteration<this.rawExaggeration[t].iteration;)++t;var n=this.rawExaggeration[t].iteration,e=this.rawExaggeration[t+1].iteration,i=this.rawExaggeration[t].value,o=this.rawExaggeration[t+1].value,n=(e-this._iteration)/(e-n),n=i*n+o*(1-n);this._exaggeration=C.scalar(n),this._exaggerationNumber=n,this.log("Exaggeration val: "+n)}else this._exaggeration=C.scalar(this.rawExaggeration)},e.prototype.logForces=function(o,r){return x(this,void 0,void 0,function(){var n,e,i;return z(this,function(t){switch(t.label){case 0:return[4,o.data()];case 1:return n=t.sent(),[4,r.data()];case 2:for(e=t.sent(),console.log("Repulsive forces"),i=0;i<e.length;i++)console.log("R"+i+":"+e[i]);for(console.log("Attractive forces"),i=0;i<n.length;i++)console.log("A"+i+":"+n[i]);return[2]}})})},e.prototype.iterate=function(){return x(this,void 0,void 0,function(){var n,e,i,o=this;return z(this,function(t){switch(t.label){case 0:if(!this.initializedNeighborhoods())throw new Error("No neighborhoods defined. You may want to call                    initializeNeighbors or initializeNeighborsFromKNNGraph");return this.updateSplatTextureDiameter(),this.updateExaggeration(),i=B(C.tidy(function(){o.splatPoints();var t=C.zeros([o.numRows,o.pointsPerRow]),n=C.zeros([o.numRows,2*o.pointsPerRow]);o.computeInterpolatedQ(t),o.computeInterpolatedXY(n);var e=t.sum(),t=n.div(e.where(e.greater(C.scalar(0)),C.scalar(1))),n=C.zeros([o.numRows,2*o.pointsPerRow]);return o.computeAttractiveForces(n),[n.mul(o._exaggeration).sub(t).mul(C.scalar(4)),e]}),2),e=i[0],n=i[1],i=this,[4,n.data()];case 1:return i._normQ=t.sent()[0],this.log("Normalization: "+this._normQ),this.log("Iteration "+this._iteration),n.dispose(),[4,this.updateEmbedding(e,this._iteration)];case 2:return e=B.apply(void 0,[t.sent(),3]),this.gradient=e[0],this.gain=e[1],this.embedding=e[2],[4,this.computeBoundaries()];case 3:return t.sent(),++this._iteration,[2]}})})},e.prototype.updateEmbedding=function(r,n){return x(this,void 0,void 0,function(){var i,o=this;return z(this,function(t){return i=n<this._momSwitchIter?this._momentum:this._finalMomentum,[2,C.tidy(function(){var t=null,n=o.applyGain?(e=(t=o.gain.add(C.scalar(.2)).where(r.sign().notEqual(o.gradient.sign()),o.gain.mul(C.scalar(.8)))).where(t.greaterEqual(C.scalar(o._minimumGain)),o.minGain),o.log("Eta: "+o._eta),o.gradient.mul(i).sub(r.mul(e.mul(C.scalar(o._eta))))):o.gradient.mul(i).sub(r.mul(C.scalar(o._eta))),e=o.embedding.add(n);return o.gradient.dispose(),o.embedding.dispose(),o.gain&&o.gain.dispose(),[n,t,e]})]})})},e.prototype.log=function(t,n){this.verbose&&(null!=n?console.log(t+": \t"+n):console.log(t))},e.prototype.initializeRepulsiveForceTextures=function(){this._splatTexture=l(this.gpgpu.gl,this.splatTextureDiameter,this.splatTextureDiameter,4,null),this.kernelSupport=2.5,this.log("Kernel support: "+this.kernelSupport+" \n      Kernel diameter: "+this.kernelTextureDiameter);for(var t=new Float32Array(this.kernelTextureDiameter*this.kernelTextureDiameter*4),n=Math.floor(this.kernelTextureDiameter/2),e=0;e<this.kernelTextureDiameter;++e)for(var i=0;i<this.kernelTextureDiameter;++i){var o=(i-n)/n*this.kernelSupport,r=(e-n)/n*this.kernelSupport,a=1/(1+(o*o+r*r)),s=4*(e*this.kernelTextureDiameter+i);t[0+s]=a,t[1+s]=a*a*o,t[2+s]=a*a*r,t[3+s]=1}this.kernelTexture=l(this.gpgpu.gl,this.kernelTextureDiameter,this.kernelTextureDiameter,4,t)},e.prototype.initilizeCustomWebGLPrograms=function(){this.log("\tCreating custom programs..."),this.embeddingInitializationProgram=this.gpgpu.createProgram("\n    precision highp float;\n\n    uniform sampler2D random_tex;\n    uniform float points_per_row;\n    uniform float num_rows;\n    uniform float num_points;\n\n    void main() {\n      //add for nearest pixel interpolation\n      vec2 half_pxl = vec2(0.5,0.5);\n\n      // Dimension of the fragment\n      // 0 -> x :1 -> y\n      float dimension = mod(gl_FragCoord.x - 0.4,2.);\n      vec2 pnt_location = gl_FragCoord.xy - half_pxl;\n      pnt_location.x = floor(pnt_location.x / 2.);\n\n      //just an extra fragment -> return\n      if(pnt_location.y*points_per_row + pnt_location.x >= num_points) {\n        gl_FragColor = vec4(0,0,0,1);\n        return;\n      }\n\n      float width = (points_per_row * 2.0);\n      float row_coord = (pnt_location.y + 0.5)/num_rows;\n      vec2 rad_coord = vec2((pnt_location.x * 2. + 0.5) / width, row_coord);\n      vec2 ang_coord = vec2((pnt_location.x * 2. + 1.5) / width, row_coord);\n\n      float rad = texture2D(random_tex,rad_coord).r * 3.;\n      float ang = texture2D(random_tex,ang_coord).r * 3.1415 * 2.;\n\n      gl_FragColor = vec4(rad,ang,0,1);\n\n      if(dimension < 0.5) {\n        gl_FragColor = vec4(cos(ang) * rad,0,0,0);\n      }else{\n        gl_FragColor = vec4(sin(ang) * rad,0,0,0);\n      }\n    }\n  "),this.embeddingSplatterProgram=s(this.gpgpu.gl,"#version 300 es\n    precision highp float;\n    in float vertex_id;\n\n    uniform sampler2D embedding_tex;\n    uniform vec2 minV;\n    uniform vec2 maxV;\n    uniform float kernel_support;\n    uniform float points_per_row;\n    //uniform float num_rows;\n\n    out vec2 kernel_coords;\n\n    void main() {\n      //TODO Clean up and check performance loss due to the conversions\n      uint pnt_id = uint((vertex_id / 4.0) + 0.1);\n      uint quad_id = uint(mod(vertex_id + 0.1,4.));\n\n      uint row    = uint((float(pnt_id) + 0.1)/points_per_row);\n      uint column = uint(float(pnt_id) - float(row) * points_per_row);\n\n      float x_pnt = texelFetch(embedding_tex, \n        ivec2(column * uint(2), row), 0).r;\n      float y_pnt = texelFetch(embedding_tex, \n        ivec2((column * uint(2)) + uint(1), row), 0).r;\n      \n      vec2 vertex_coords = vec2(x_pnt,y_pnt);\n\n      if(quad_id == uint(0)) {kernel_coords = vec2(-1,-1);}\n      else if(quad_id == uint(1)) {kernel_coords = vec2(1,-1);}\n      else if(quad_id == uint(2)) {kernel_coords = vec2(1,1);}\n      else if(quad_id == uint(3)) {kernel_coords = vec2(-1,1);}\n\n      // map the vertex coord to clip space by combining\n      // the kernel point offset (scaled by the support)\n      // with the  \n      vertex_coords += kernel_coords * kernel_support; //embedding space\n      vertex_coords = (vertex_coords - minV) / (maxV-minV); //  0:1 space\n      vertex_coords = vertex_coords * 2.0 - 1.0;            // -1:1 space\n\n      gl_Position = vec4(vertex_coords,0,1);\n    }\n  ","#version 300 es\n    precision highp float;\n    uniform sampler2D kernel_tex;\n    in vec2 kernel_coords;\n    out vec4 fragmentColor;\n\n    void main() {\n      fragmentColor = texture(kernel_tex,(kernel_coords + 1.) / 2.0);\n    }\n  ");for(var t,n=new Float32Array(6*this.numPoints),e=0;e<this.numPoints;++e)n[0+(t=6*e)]=0+4*e,n[1+t]=1+4*e,n[2+t]=2+4*e,n[3+t]=0+4*e,n[4+t]=2+4*e,n[5+t]=3+4*e;this.splatVertexIdBuffer=C.webgl.webgl_util.createStaticVertexBuffer(this.gpgpu.gl,n),this.qInterpolatorProgram=this.gpgpu.createProgram("\n    precision highp float;\n    uniform sampler2D embedding_tex;\n    uniform sampler2D splat_tex;\n    uniform vec2 minV;\n    uniform vec2 maxV;\n    uniform float points_per_row;\n    uniform float num_rows;\n    uniform float num_points;\n\n    void main() {\n      vec2 pnt_location = gl_FragCoord.xy - vec2(0.5,0.5);\n\n      if(pnt_location.y * points_per_row + pnt_location.x >= num_points) {\n        gl_FragColor = vec4(0,0,0,0);\n        return;\n      }\n\n      float emb_width = (points_per_row * 2.0);\n      float emb_row_coord = (pnt_location.y + 0.5) / num_rows;\n      vec2 emb_coords_x\n              = vec2((pnt_location.x * 2. + 0.5) / emb_width, emb_row_coord);\n      vec2 emb_coords_y\n              = vec2((pnt_location.x * 2. + 1.5) / emb_width, emb_row_coord);\n\n      float x_pnt = texture2D(embedding_tex,emb_coords_x).r;\n      float y_pnt = texture2D(embedding_tex,emb_coords_y).r;\n\n      vec2 splat_coords = vec2(x_pnt,y_pnt);\n      splat_coords = (splat_coords - minV) / (maxV - minV); //  0:1 space\n\n      float q = max(texture2D(splat_tex,splat_coords).r - 1., 0.);\n      \n      gl_FragColor = vec4(q, 0, 0, 1);\n    }\n  "),this.xyInterpolatorProgram=this.gpgpu.createProgram("\n    precision highp float;\n    uniform sampler2D embedding_tex;\n    uniform sampler2D splat_tex;\n    uniform vec2 minV;\n    uniform vec2 maxV;\n    uniform float points_per_row;\n    uniform float num_rows;\n    uniform float num_points;\n    //uniform float eta;\n\n    void main() {\n      vec2 pnt_location = gl_FragCoord.xy - vec2(0.5,0.5);\n      pnt_location.x = floor(pnt_location.x/2.+0.1);\n\n      if(pnt_location.y*points_per_row + pnt_location.x >= num_points) {\n        gl_FragColor = vec4(0,0,0,0);\n        return;\n      }\n\n      float emb_width = (points_per_row * 2.0);\n      float emb_row_coord = (pnt_location.y + 0.5) / num_rows;\n      vec2 emb_coords_x\n              = vec2((pnt_location.x * 2. + 0.5) / emb_width, emb_row_coord);\n      vec2 emb_coords_y\n              = vec2((pnt_location.x * 2. + 1.5) / emb_width, emb_row_coord);\n\n      float x_pnt = texture2D(embedding_tex,emb_coords_x).r;\n      float y_pnt = texture2D(embedding_tex,emb_coords_y).r;\n\n      vec2 splat_coords = vec2(x_pnt,y_pnt);\n      splat_coords = (splat_coords - minV) / (maxV - minV); //  0:1 space\n\n      float q = 0.;\n      // eta moved to updateEmbedding code\n      if(mod(gl_FragCoord.x - 0.5,2.) < 0.5 ) {\n        q = texture2D(splat_tex,splat_coords).g;\n      }else{\n        q = texture2D(splat_tex,splat_coords).b;\n      }\n\n      gl_FragColor = vec4(q,0.0,0.0,1);\n    }\n  "),this.attractiveForcesProgram=this.gpgpu.createProgram("\n    precision highp float;\n\n    uniform sampler2D embedding_tex;\n    uniform sampler2D offset_tex;\n    uniform sampler2D neigh_id_tex;\n    uniform sampler2D neigh_prob_tex;\n\n    uniform float points_per_row;\n    uniform float num_rows;\n    uniform float num_points;\n    uniform float num_neighs_per_row;\n    //uniform float eta;\n\n    void main() {\n      //add for nearest pixel interpolation\n      vec2 half_pxl = vec2(0.5,0.5);\n\n      // Dimension of the fragment\n      // 0 -> x :1 -> y\n      float dimension = mod(gl_FragCoord.x - 0.4,2.);\n\n      //Point location in the [points_per_row,num_rows] space\n      vec2 i_location = gl_FragCoord.xy - half_pxl;\n      i_location.x = floor(i_location.x / 2. + 0.1);\n\n      //just an extra fragment -> return\n      if(i_location.y*points_per_row + i_location.x >= num_points) {\n        gl_FragColor = vec4(0,0,0,0);\n        return;\n      }\n\n      //Offset coordinates for the point\n      vec2 offset_coord = (i_location + half_pxl) /\n                                              vec2(points_per_row,num_rows);\n      //Offset information ...\n      vec4 offset_info  = texture2D(offset_tex,offset_coord);\n      //... contains the number of neighbors for the point ...\n      float num_neighs  = offset_info.z;\n      //... and the coordinates of the firts neigh in the neigh textures\n      vec2 offset_neigh = offset_info.xy;\n\n      //Computing the coordinates of the point in the texture\n      //_i represent the point to move, _j the neighbors\n      float emb_width = (points_per_row * 2.0);\n      float emb_row_i = (i_location.y + 0.5) / num_rows;\n      vec2 x_i_coord = vec2((i_location.x * 2. + 0.5) / emb_width, emb_row_i);\n      vec2 y_i_coord = vec2((i_location.x * 2. + 1.5) / emb_width, emb_row_i);\n      //getting the coordinates in the embedding\n      float x_i = texture2D(embedding_tex,x_i_coord).r;\n      float y_i = texture2D(embedding_tex,y_i_coord).r;\n\n      //Sum of all attractive forces\n      float sum_pos = 0.;\n      float sum_qij = 0.;\n      float sum_distx2 = 0.;\n      float sum_disty2 = 0.;\n\n      //Can't be higher than 1000 (perplexity is usually around 30)\n      //and a 'while' can't be used\n      for(int n = 0; n < 2000; ++n) {\n        //Actual check on number of neighbors\n        if(float(n) >= num_neighs) {\n          break;\n        }\n\n        //Get the id and the probability for the neighbor\n        float pij = texture2D(neigh_prob_tex,\n                              (offset_neigh + half_pxl) / num_neighs_per_row\n                             ).r;\n        float neigh_id = texture2D(neigh_id_tex,\n                                  (offset_neigh + half_pxl) / num_neighs_per_row\n                                  ).r;\n\n        //Getting the coordinates of the neighbor\n        vec2 j_location = vec2(mod(neigh_id + 0.1, points_per_row),\n                               floor(neigh_id / points_per_row + 0.1));\n        float emb_row_j = (j_location.y + 0.5) / num_rows;\n        vec2 x_j_coord = vec2((j_location.x * 2. + 0.5) / emb_width, emb_row_j);\n        vec2 y_j_coord = vec2((j_location.x * 2. + 1.5) / emb_width, emb_row_j);\n        float x_j = texture2D(embedding_tex,x_j_coord).r;\n        float y_j = texture2D(embedding_tex,y_j_coord).r;\n\n        //Actual computation of the attractive forces\n        float dist_x    = (x_i - x_j);\n        float dist_y    = (y_i - y_j);\n        float qij       = 1. / (1. + (dist_x * dist_x) + (dist_y * dist_y));\n        sum_distx2 += dist_x * dist_x;\n        sum_disty2 += dist_y * dist_y;\n        sum_qij += qij;\n        //the update depends on the dimension that this fragment represents\n        if(dimension < 0.5) {\n          // * 4 / (num_points*2) -> * 2 / num_points\n          //<bvl 1- fix attractive force calculation>\n          //sum_pos += eta * 2. * pij * qij * dist_x / (num_points); \n          // <bvl> remove eta * 2.\n          sum_pos += pij * qij * dist_x / (2.0 * num_points);\n        } else {\n          //<bvl 1- fix attractive force calculation>\n          //sum_pos += eta * 2. * pij * qij * dist_y / (num_points);\n          // <bvl> remove eta * 2.\n          sum_pos += pij * qij * dist_y / (2.0 * num_points);\n        }\n\n        //Increase the coordinate of the neigh in the neigh_id texture\n        offset_neigh.x += 1.;\n        //check if the new neigh is in the next row\n        if(offset_neigh.x + 0.2 > num_neighs_per_row) {\n          //in that case reset the column and increase the row\n          offset_neigh.x = 0.1;\n          offset_neigh.y += 1.0;\n        }\n      }\n\n      //The output is the sum of the attractive forces\n      gl_FragColor = vec4(sum_pos,dimension,0,1);\n    }\n  "),this.distributionParameterssComputationProgram=this.gpgpu.createProgram("\n    precision highp float;\n\n    #define MAX_NEIGHBORS 128\n    #define MAX_ITERATIONS 500\n    #define FLOAT_MAX 10e30\n    #define FLOAT_MIN 10e-30;\n    #define TOLERANCE 1e-5\n\n    uniform sampler2D knn_graph_tex;\n    uniform float points_per_row;\n    uniform float num_rows;\n    uniform float num_points;\n    uniform float num_neighs;\n    uniform float perplexity;\n\n    vec2 half_pixel = vec2(0.5,0.5);\n    float distances_squared[MAX_NEIGHBORS];\n\n    void readDistances(vec2 point_location) {\n      for(int n = 0; n < MAX_NEIGHBORS; ++n ) {\n        if(float(n) >= num_neighs-0.1) {\n          break;\n        }\n        vec2 knn_coordinates = vec2(\n            (point_location.x * num_neighs + float(n) + half_pixel.x)\n                                        /(points_per_row * num_neighs),\n            (point_location.y + half_pixel.y) / num_rows\n        );\n        distances_squared[n] = texture2D(knn_graph_tex,knn_coordinates).g;\n      }\n    }\n\n    void main() {\n      vec2 point_location = gl_FragCoord.xy - half_pixel;\n      //invalid points\n      if(point_location.y*points_per_row + point_location.x >= num_points) {\n        gl_FragColor = vec4(0,0,0,0);\n        return;\n      }\n      readDistances(point_location);\n\n      //Beta computation\n      float beta = 1.;\n      float max_beta = FLOAT_MAX;\n      float min_beta = -FLOAT_MAX;\n      //To avoid computing the log at every iteration\n      float log_perplexity = log(perplexity);\n      float entropy_diff = 0.;\n      float entropy = 0.;\n      float sum_probabilities = FLOAT_MIN;\n\n      //Binary search for a maximum of MAX_ITERATIONS\n      for(int iteration = 0; iteration < MAX_ITERATIONS; ++iteration) {\n        //At every iteration I compute the\n        //entropy enforced by the current beta\n        sum_probabilities = FLOAT_MIN;\n        entropy = 0.;\n        for(int n = 0; n < MAX_NEIGHBORS; ++n ) {\n          if(float(n) >= num_neighs-0.1) {\n            break;\n          }\n          float neigh_probability = exp(-beta * distances_squared[n]);\n          sum_probabilities += neigh_probability;\n          entropy += beta * distances_squared[n] * neigh_probability;\n        }\n\n        entropy = (entropy / sum_probabilities) + log(sum_probabilities);\n        entropy_diff = entropy - log_perplexity;\n\n        //the current beta is good enough!\n        if(entropy_diff < TOLERANCE && -entropy_diff < TOLERANCE) {\n          break;\n        }\n\n        if(entropy_diff > 0.) {\n          min_beta = beta;\n          if(max_beta == FLOAT_MAX || max_beta == -FLOAT_MAX) {\n            beta *= 2.;\n          }else{\n            beta = (beta + max_beta) / 2.;\n          }\n        }else{\n          max_beta = beta;\n          if(min_beta == -FLOAT_MAX || min_beta == FLOAT_MAX) {\n            beta /= 2.;\n          }else{\n            beta = (beta + min_beta) / 2.;\n          }\n        }\n      }\n      gl_FragColor = vec4(beta,sum_probabilities,0,1);\n    }\n  "),this.gaussiaDistributionsFromDistancesProgram=this.gpgpu.createProgram("\n    precision highp float;\n    uniform sampler2D knn_graph_tex;\n    uniform sampler2D parameters_tex;\n    uniform float points_per_row;\n    uniform float num_rows;\n    uniform float num_points;\n    uniform float num_neighs;\n\n    vec2 half_pixel = vec2(0.5,0.5);\n\n    void main() {\n      vec2 point_location = gl_FragCoord.xy - half_pixel;\n      point_location.x = floor(point_location.x / num_neighs);\n\n      //invalid points\n      if(point_location.y*points_per_row + point_location.x >= num_points) {\n        gl_FragColor = vec4(0,0,0,0);\n        return;\n      }\n      float distance_squared\n            = texture2D(knn_graph_tex,\n                        gl_FragCoord.xy /\n                        vec2(points_per_row*num_neighs,num_rows)\n                      ).g;\n      vec2 parameters\n            = texture2D(parameters_tex,\n                        (point_location.xy + half_pixel)/\n                        vec2(points_per_row,num_rows)\n                      ).rg;\n      float beta = parameters.r;\n      float normalization = parameters.g;\n\n      float probability = exp(-beta * distance_squared) / normalization;\n      //check for NaN for degenerated knn (d = 0 for every point)\n      if (!(probability < 0.0 || 0.0 < probability || probability == 0.0)) {\n        probability = 0.;\n      }\n\n      gl_FragColor = vec4(probability,0,0,1);\n    }\n  ")},e.prototype.computeBoundaries=function(){return x(this,void 0,void 0,function(){var n,e,i,o,r,a=this;return z(this,function(t){switch(t.label){case 0:return r=B(C.tidy(function(){var t=a.embedding.reshape([a.numRows*a.pointsPerRow,2]).slice([0,0],[a.numPoints,2]);return[t.min(0),t.max(0)]}),2),n=r[0],e=r[1],[4,n.data()];case 1:return i=t.sent(),[4,e.data()];case 2:return o=t.sent(),r=.05*(o[0]-i[0]),this._minX=i[0]-r,this._maxX=o[0]+r,r=.05*(o[1]-i[1]),this._minY=i[1]-r,this._maxY=o[1]+r,n.dispose(),e.dispose(),[2]}})})},e.prototype.calculateTexSize=function(t){return Math.min(5e3,Math.max(Math.floor(t/this._spacePerPixel),5))},e.prototype.updateSplatTextureDiameter=function(){var t=this._maxX-this._minX,n=this._maxY-this._minY,n=Math.max(t,n);this.log("Embedding range: "+n);n=this.calculateTexSize(n);.2<=Math.abs((n-this.splatTextureDiameter)/this.splatTextureDiameter)?(this.log("Change splat size: "+this._iteration),this.gpgpu.gl.deleteTexture(this._splatTexture),this.splatTextureDiameter=Math.ceil(n),this.log("Splat diameter: "+this.splatTextureDiameter),this._splatTexture=l(this.gpgpu.gl,this.splatTextureDiameter,this.splatTextureDiameter,4,null)):this.log("Splat diameter: "+this.splatTextureDiameter)},e.prototype.initializeEmbeddingPositions=function(t,n){var e,i,o,r,a,s;e=this.gpgpu,i=this.embeddingInitializationProgram,o=this.backend.getTexture(n.dataId),r=this.numPoints,a=this.pointsPerRow,s=this.numRows,n=this.backend.getTexture(t.dataId),t=e.gl,null!=n?e.setOutputMatrixTexture(n,s,2*a):C.webgl.webgl_util.bindCanvasToFramebuffer(e.gl),e.setProgram(i),n=C.webgl.webgl_util.getProgramUniformLocationOrThrow(t,i,"random_tex"),e.setInputMatrixTexture(o,n,3),n=C.webgl.webgl_util.getProgramUniformLocationOrThrow(t,i,"num_rows"),t.uniform1f(n,s),s=C.webgl.webgl_util.getProgramUniformLocationOrThrow(t,i,"num_points"),t.uniform1f(s,r),i=C.webgl.webgl_util.getProgramUniformLocationOrThrow(t,i,"points_per_row"),t.uniform1f(i,a),e.executeProgram()},e.prototype.splatPoints=function(){var t,n,e,i,o,r,a,s,l,u,h,g,p,m,d,f,_;t=this.gpgpu,n=this.embeddingSplatterProgram,e=this._splatTexture,i=this.backend.getTexture(this.embedding.dataId),o=this.kernelTexture,r=this.splatTextureDiameter,a=this.splatTextureDiameter,s=this.numPoints,l=this._minX,u=this._minY,h=this._maxX,g=this._maxY,p=this.kernelSupport,m=this.pointsPerRow,this.numRows,d=this.splatVertexIdBuffer,f=t.gl,_=t.program,null!=e?t.setOutputMatrixTexture(e,r,a):C.webgl.webgl_util.bindCanvasToFramebuffer(t.gl),t.setProgram(n),f.clearColor(0,0,0,0),f.clear(f.COLOR_BUFFER_BIT),f.enable(f.BLEND),f.blendFunc(f.ONE,f.ONE),C.webgl.webgl_util.callAndCheck(f,function(){return f.bindBuffer(f.ARRAY_BUFFER,d)}),C.webgl.webgl_util.bindVertexBufferToProgramAttribute(f,n,"vertex_id",d,1,0,0),a=C.webgl.webgl_util.getProgramUniformLocationOrThrow(f,n,"embedding_tex"),t.setInputMatrixTexture(i,a,0),a=C.webgl.webgl_util.getProgramUniformLocationOrThrow(f,n,"kernel_tex"),t.setInputMatrixTexture(o,a,1),a=C.webgl.webgl_util.getProgramUniformLocationOrThrow(f,n,"kernel_support"),f.uniform1f(a,p),p=C.webgl.webgl_util.getProgramUniformLocationOrThrow(f,n,"points_per_row"),f.uniform1f(p,m),m=C.webgl.webgl_util.getProgramUniformLocationOrThrow(f,n,"minV"),f.uniform2f(m,l,u),n=C.webgl.webgl_util.getProgramUniformLocationOrThrow(f,n,"maxV"),f.uniform2f(n,h,g),C.webgl.webgl_util.callAndCheck(f,function(){return f.drawArrays(f.TRIANGLES,0,2*s*3)}),f.disable(f.BLEND),null!=_&&(t.setProgram(_),C.webgl.gpgpu_util.bindVertexProgramAttributeStreams(t.gl,_,t.vertexBuffer))},e.prototype.computeInterpolatedQ=function(t){var n,e,i,o,r,a,s,l,u,h,g,p;n=this.gpgpu,e=this.qInterpolatorProgram,i=this._splatTexture,o=this.backend.getTexture(this.embedding.dataId),r=this.numPoints,a=this._minX,s=this._minY,l=this._maxX,u=this._maxY,h=this.pointsPerRow,g=this.numRows,p=this.backend.getTexture(t.dataId),t=n.gl,null!=p?n.setOutputMatrixTexture(p,g,h):C.webgl.webgl_util.bindCanvasToFramebuffer(n.gl),n.setProgram(e),p=C.webgl.webgl_util.getProgramUniformLocationOrThrow(t,e,"embedding_tex"),n.setInputMatrixTexture(o,p,0),p=C.webgl.webgl_util.getProgramUniformLocationOrThrow(t,e,"splat_tex"),n.setInputMatrixTexture(i,p,1),p=C.webgl.webgl_util.getProgramUniformLocationOrThrow(t,e,"points_per_row"),t.uniform1f(p,h),h=C.webgl.webgl_util.getProgramUniformLocationOrThrow(t,e,"num_rows"),t.uniform1f(h,g),g=C.webgl.webgl_util.getProgramUniformLocationOrThrow(t,e,"num_points"),t.uniform1f(g,r),r=C.webgl.webgl_util.getProgramUniformLocationOrThrow(t,e,"minV"),t.uniform2f(r,a,s),e=C.webgl.webgl_util.getProgramUniformLocationOrThrow(t,e,"maxV"),t.uniform2f(e,l,u),n.executeProgram()},e.prototype.computeInterpolatedXY=function(t){var n,e,i,o,r,a,s,l,u,h,g,p;n=this.gpgpu,e=this.xyInterpolatorProgram,i=this._splatTexture,o=this.backend.getTexture(this.embedding.dataId),r=this.backend.getTexture(t.dataId),a=this.numPoints,s=this._minX,l=this._minY,u=this._maxX,h=this._maxY,g=this.pointsPerRow,p=this.numRows,this._eta,t=n.gl,null!=r?n.setOutputMatrixTexture(r,p,2*g):C.webgl.webgl_util.bindCanvasToFramebuffer(n.gl),n.setProgram(e),r=C.webgl.webgl_util.getProgramUniformLocationOrThrow(t,e,"embedding_tex"),n.setInputMatrixTexture(o,r,0),r=C.webgl.webgl_util.getProgramUniformLocationOrThrow(t,e,"splat_tex"),n.setInputMatrixTexture(i,r,1),r=C.webgl.webgl_util.getProgramUniformLocationOrThrow(t,e,"points_per_row"),t.uniform1f(r,g),g=C.webgl.webgl_util.getProgramUniformLocationOrThrow(t,e,"num_rows"),t.uniform1f(g,p),p=C.webgl.webgl_util.getProgramUniformLocationOrThrow(t,e,"num_points"),t.uniform1f(p,a),a=C.webgl.webgl_util.getProgramUniformLocationOrThrow(t,e,"minV"),t.uniform2f(a,s,l),e=C.webgl.webgl_util.getProgramUniformLocationOrThrow(t,e,"maxV"),t.uniform2f(e,u,h),n.executeProgram()},e.prototype.computeAttractiveForces=function(t){var n,e,i,o,r,a,s,l,u,h,g;n=this.gpgpu,e=this.attractiveForcesProgram,i=this.backend.getTexture(this.embedding.dataId),o=this.probOffsetTexture,r=this.probNeighIdTexture,a=this.probTexture,s=this.numPoints,l=this.numNeighPerRow,u=this.pointsPerRow,h=this.numRows,this._eta,g=this.backend.getTexture(t.dataId),t=n.gl,null!=g?n.setOutputMatrixTexture(g,h,2*u):C.webgl.webgl_util.bindCanvasToFramebuffer(n.gl),n.setProgram(e),g=C.webgl.webgl_util.getProgramUniformLocationOrThrow(t,e,"embedding_tex"),n.setInputMatrixTexture(i,g,3),g=C.webgl.webgl_util.getProgramUniformLocationOrThrow(t,e,"offset_tex"),n.setInputMatrixTexture(o,g,2),g=C.webgl.webgl_util.getProgramUniformLocationOrThrow(t,e,"neigh_id_tex"),n.setInputMatrixTexture(r,g,1),g=C.webgl.webgl_util.getProgramUniformLocationOrThrow(t,e,"neigh_prob_tex"),n.setInputMatrixTexture(a,g,0),g=C.webgl.webgl_util.getProgramUniformLocationOrThrow(t,e,"num_rows"),t.uniform1f(g,h),h=C.webgl.webgl_util.getProgramUniformLocationOrThrow(t,e,"num_neighs_per_row"),t.uniform1f(h,l),l=C.webgl.webgl_util.getProgramUniformLocationOrThrow(t,e,"num_points"),t.uniform1f(l,s),e=C.webgl.webgl_util.getProgramUniformLocationOrThrow(t,e,"points_per_row"),t.uniform1f(e,u),n.executeProgram()},e.prototype.computeDistributionParameters=function(t,n,e,i){!function(t,n,e,i,o,r,a,s,l){var u=t.gl;try{null!=l?t.setOutputMatrixTexture(l,a,r):C.webgl.webgl_util.bindCanvasToFramebuffer(t.gl),t.setProgram(n);var h=C.webgl.webgl_util.getProgramUniformLocationOrThrow(u,n,"knn_graph_tex");t.setInputMatrixTexture(e,h,0);h=C.webgl.webgl_util.getProgramUniformLocationOrThrow(u,n,"num_rows");u.uniform1f(h,a);h=C.webgl.webgl_util.getProgramUniformLocationOrThrow(u,n,"num_points");u.uniform1f(h,i);h=C.webgl.webgl_util.getProgramUniformLocationOrThrow(u,n,"points_per_row");u.uniform1f(h,r);h=C.webgl.webgl_util.getProgramUniformLocationOrThrow(u,n,"num_neighs");u.uniform1f(h,o);h=C.webgl.webgl_util.getProgramUniformLocationOrThrow(u,n,"perplexity");u.uniform1f(h,s),t.executeProgram()}catch(t){console.log("Error in executeDistributionParametersComputationProgram"+t.toString())}}(this.gpgpu,this.distributionParameterssComputationProgram,i,n.numPoints,n.pixelsPerPoint,n.pointsPerRow,n.numRows,e,t)},e.prototype.computeGaussianDistributions=function(t,n,e,i){t=this.backend.getTexture(t.dataId);!function(t,n,e,i,o,r,a,s,l){var u=t.gl;try{t.enableAutomaticDebugValidation(!0),null!=l?t.setOutputMatrixTexture(l,s,a*r):C.webgl.webgl_util.bindCanvasToFramebuffer(t.gl),t.setProgram(n);var h=C.webgl.webgl_util.getProgramUniformLocationOrThrow(u,n,"knn_graph_tex");t.setInputMatrixTexture(e,h,0);h=C.webgl.webgl_util.getProgramUniformLocationOrThrow(u,n,"parameters_tex");t.setInputMatrixTexture(i,h,1);h=C.webgl.webgl_util.getProgramUniformLocationOrThrow(u,n,"num_rows");u.uniform1f(h,s);h=C.webgl.webgl_util.getProgramUniformLocationOrThrow(u,n,"num_points");u.uniform1f(h,o);h=C.webgl.webgl_util.getProgramUniformLocationOrThrow(u,n,"points_per_row");u.uniform1f(h,a);h=C.webgl.webgl_util.getProgramUniformLocationOrThrow(u,n,"num_neighs");u.uniform1f(h,r),console.log("Execute Gaussion Dist from Distances"),t.executeProgram()}catch(t){console.log("Error executing Gaussian Dist From Distances Program "+t.toString())}}(this.gpgpu,this.gaussiaDistributionsFromDistancesProgram,i,n,e.numPoints,e.pixelsPerPoint,e.pointsPerRow,e.numRows,t)},e);function e(t,n,e,i){if(this.verbose=null!=n&&n,this.log("Initializing the tSNE gradient descent computation..."),this.numPoints=t,this._iteration=0,1===C.ENV.get("WEBGL_VERSION"))throw Error("WebGL version 1 is not supported by tfjs-tsne");if(this.backend=C.ENV.findBackend("webgl"),null===this.backend)throw Error("WebGL backend is not available");this.gpgpu=this.backend.getGPGPUContext(),C.webgl.webgl_util.getExtensionOrThrow(this.gpgpu.gl,"OES_texture_float_linear"),this.pointsPerRow=Math.ceil(Math.sqrt(2*t)),this.pointsPerRow%2==1&&++this.pointsPerRow,this.pointsPerRow/=2,this.numRows=Math.ceil(t/this.pointsPerRow),this.log("\t# points per row",this.pointsPerRow),this.log("\t# rows",this.numRows),this._eta=200,this._spacePerPixel=.35,this._minimumGain=.1,this._momentum=C.scalar(.5),this._finalMomentum=C.scalar(.5),this._momSwitchIter=250,this.rawExaggeration=[{iteration:200,value:4},{iteration:600,value:1}],this.updateExaggeration(),null==e&&(e=5),this.splatTextureDiameter=e,null==i&&(i=50),this.kernelTextureDiameter=2*i+1,this.initializeRepulsiveForceTextures(),this.log("\tSplat texture diameter",this.splatTextureDiameter),this.log("\tKernel texture diameter",this.kernelTextureDiameter),this.initilizeCustomWebGLPrograms(),this.initializeEmbedding(),this.log("\tEmbedding",this.embedding),this.log("\tGradient",this.gradient)}function i(){var t=C.ENV.findBackend("webgl");if(null===t)throw Error("WebGL backend is not available");t=t.getGPGPUContext().gl,t=4*(t.getParameter(t.MAX_VARYING_VECTORS)-1);return Math.floor(t/3)}var r=(a.prototype.initialize=function(){return x(this,void 0,void 0,function(){var n,e,i,o,r,a;return z(this,function(t){switch(t.label){case 0:return r=18,n=4,e=250,a=150,i=.5,o=!0,this.verbose=!1,this.knnMode="auto",void 0!==this.config&&(void 0!==this.config.perplexity&&(r=this.config.perplexity),void 0!==this.config.exaggeration&&(n=this.config.exaggeration),void 0!==this.config.exaggerationIter&&(e=this.config.exaggerationIter),void 0!==this.config.exaggerationDecayIter&&(a=this.config.exaggerationDecayIter),void 0!==this.config.momentum&&(i=this.config.momentum),void 0!==this.config.applyGain&&(o=this.config.applyGain),void 0!==this.config.verbose&&(this.verbose=this.config.verbose),void 0!==this.config.knnMode&&(this.knnMode=this.config.knnMode)),this.appliedPerplexity=r,this.numNeighbors=4*Math.floor(3*r/4),r=this,[4,function(m){return x(this,void 0,void 0,function(){var n,e,i,o,r,a,s,l,u,h,g,p;return z(this,function(t){if(2!==(r=m.shape).length)throw Error("tensorToDataTexture: input tensor must be 2-dimensional");if(null===(o=C.ENV.findBackend("webgl")))throw Error("WebGL backend is not available");for(p=o.getGPGPUContext(),n=r[0],e=r[1],i=Math.ceil(e/4),o=Math.max(1,Math.floor(Math.sqrt(n*i)/i)),r=Math.ceil(n/o),a=m.dataSync(),s=new Float32Array(o*i*r*4),l=0;l<n;++l)for(u=l*e,h=l*i*4,g=0;g<e;++g)s[h+g]=a[u+g];return p=M(p.gl,o*i,r,4,s),[2,{shape:{numPoints:n,pointsPerRow:o,numRows:r,pixelsPerPoint:i},texture:p}]})})}(this.data)];case 1:return r.packedData=t.sent(),this.verbose&&(console.log("Number of points:\t"+this.numPoints),console.log("Number of dimensions:\t "+this.numDimensions),console.log("Number of neighbors:\t"+this.numNeighbors),console.log("kNN mode:\t"+this.knnMode)),this.knnEstimator=new b(this.packedData.texture,this.packedData.shape,this.numPoints,this.numDimensions,this.numNeighbors,this.verbose),this.optimizer=new w(this.numPoints,this.verbose),a=[{iteration:e,value:n},{iteration:e+a,value:1}],this.verbose&&console.log("Exaggerating for "+a[0].iteration+" iterations with a value of "+a[0].value+". Exaggeration is removed after "+a[1].iteration+"."),this.optimizer.exaggeration=a,this.optimizer.momentum=i,this.optimizer.applyGain=o,2e3<this.numPoints?this.optimizer.eta=500:this.optimizer.eta=200+this.numPoints/2e3*300,this.optimizer.spacePerPixel=.2,this.initialized=!0,this.verbose&&console.log("initialized"),[2]}})})},a.prototype.compute=function(e){return void 0===e&&(e=1e3),x(this,void 0,void 0,function(){var n;return z(this,function(t){switch(t.label){case 0:return n=this.knnIterations(),this.verbose&&(console.log("Number of KNN iterations:\t"+n),console.log("Computing the KNN...")),[4,this.iterateKnn(n)];case 1:return t.sent(),this.verbose&&console.log("Computing the tSNE embedding..."),[4,this.iterate(e)];case 2:return t.sent(),this.verbose&&console.log("Done!"),[2]}})})},a.prototype.iterateKnn=function(e){return void 0===e&&(e=1),x(this,void 0,void 0,function(){var n;return z(this,function(t){switch(t.label){case 0:return this.initialized?[3,2]:[4,this.initialize()];case 1:t.sent(),t.label=2;case 2:this.probabilitiesInitialized=!1,n=0,t.label=3;case 3:return n<e?(this.knnEstimator.iterateKNNDescent(),this.knnEstimator.iteration%100==0&&this.verbose&&console.log("Iteration KNN:\t"+this.knnEstimator.iteration),C.ENV.get("IS_CHROME")&&this.knnEstimator.iteration%5==0?[4,this.knnEstimator.forceSync()]:[3,5]):[3,6];case 4:t.sent(),t.label=5;case 5:return++n,[3,3];case 6:return[2]}})})},a.prototype.iterate=function(e){return void 0===e&&(e=1),x(this,void 0,void 0,function(){var n;return z(this,function(t){switch(t.label){case 0:return this.probabilitiesInitialized?[3,2]:[4,this.initializeProbabilities()];case 1:t.sent(),t.label=2;case 2:n=0,t.label=3;case 3:return n<e?[4,this.optimizer.iterate()]:[3,6];case 4:t.sent(),this.optimizer.iteration%100==0&&this.verbose&&console.log("Iteration tSNE:\t"+this.optimizer.iteration),t.label=5;case 5:return++n,[3,3];case 6:return[2]}})})},a.prototype.knnIterations=function(){return Math.ceil(this.numPoints/20)},a.prototype.coordinates=function(t){var r=this;return(t=void 0===t?!0:t)?C.tidy(function(){var t=r.optimizer.maxX-r.optimizer.minX,n=r.optimizer.maxY-r.optimizer.minY,e=C.tensor2d([r.optimizer.minX,r.optimizer.minY],[1,2]),i=C.tensor2d([r.optimizer.maxX,r.optimizer.maxY],[1,2]).sub(e),o=C.max(C.tensor(i.dataSync())),i=C.tidy(function(){return t<n?C.tensor2d([(n-t)/2,0],[1,2]):C.tensor2d([0,(t-n)/2],[1,2])});return r.optimizer.embedding2D.sub(e).add(i).div(o)}):this.optimizer.embedding2D},a.prototype.coordsArray=function(o){return void 0===o&&(o=!0),x(this,void 0,void 0,function(){var n,e,i;return z(this,function(t){switch(t.label){case 0:return[4,this.coordinates(o).data()];case 1:for(n=t.sent(),e=[],i=0;i<n.length;i+=2)e.push([n[i],n[i+1]]);return[2,e]}})})},a.prototype.knnTotalDistance=function(){return x(this,void 0,void 0,function(){var n=this;return z(this,function(t){switch(t.label){case 0:return[4,C.tidy(function(){return n.knnEstimator.distancesTensor().sum()}).data()];case 1:return[2,t.sent()[0]]}})})},a.prototype.setKnnData=function(n,e,i,o){return x(this,void 0,void 0,function(){return z(this,function(t){switch(t.label){case 0:return this.initialized?[3,2]:[4,this.initialize()];case 1:t.sent(),t.label=2;case 2:return this.probabilitiesInitialized=!1,[4,this.optimizer.initializeNeighborsFromKNNGraph(n,e,i,o,this.appliedPerplexity)];case 3:return t.sent(),this.probabilitiesInitialized=!0,[2]}})})},a.prototype.initializeProbabilities=function(){return x(this,void 0,void 0,function(){return z(this,function(t){switch(t.label){case 0:return this.verbose&&console.log("Initializing probabilities"),[4,this.optimizer.initializeNeighborsFromKNNTexture(this.knnEstimator.knnShape,this.knnEstimator.knn(),this.appliedPerplexity)];case 1:return t.sent(),this.verbose&&console.log("Initialized probabilities from kNN Texture"),this.probabilitiesInitialized=!0,[2]}})})},a);function a(t,n){this.initialized=!1,this.probabilitiesInitialized=!1,this.data=t,this.config=n;t=this.data.shape;if(this.numPoints=t[0],this.numDimensions=t[1],2!==t.length)throw Error("computeTSNE: input tensor must be 2-dimensional");n=18;void 0!==this.config&&void 0!==this.config.perplexity&&(n=this.config.perplexity);t=i();if(t<n)throw Error("computeTSNE: perplexity cannot be greater than"+t+" on this machine");this.appliedPerplexity=n}t.KNNEstimator=b,t.TSNEOptimizer=w,t.maximumPerplexity=i,t.tsne=function(t,n){return new r(t,n)},Object.defineProperty(t,"__esModule",{value:!0})});